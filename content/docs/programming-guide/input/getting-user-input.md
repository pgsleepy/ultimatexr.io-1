---
title: "Getting User Input"
---

# Getting User Input

{{% callout info %}}
This guide provides a detailed analysis of user input. For brief snippets visit the [Input](/docs/programming-guide/how-do-i#inputtracking) section in [How do I...?](/docs/programming-guide/how-do-i).
{{% /callout %}}

## `UxrControllerInput`

The active `UxrControllerInput` component can be accessed using `UxrAvatar.LocalAvatarInput`. The `LocalAvatarInput` is a static property, which means it can be used globally from anywhere in the code. It will return the currently active controller input component, or a dummy component if no controller is currently active.
A dummy controller input removes the need for null checks and will not generate any input events.

## Controller Type

`UxrControllerInput` exposes the `SetupType` property, which can have the following values:
- `UxrControllerSetupType.Single`: Single controller setup, such as a gamepad, remote or a gun.
- `UxrControllerSetupType.Dual`: Dual controller setup (left+right controllers).

![](/media/docs/programming-guide/input/getting-user-input/ControllerTypes.png)
**Image**: A dual controller setup on the left (Quest 3 controllers) and single controllers on the right (Oculus Go and Gamepad).

## Controller Capabilities

`UxrControllerInput` also exposes the `GetControllerCapabilities()` method, which will return `UxrControllerInputCapabilities` flags:
- `HapticImpulses`: The controller supports raw haptic impulses.
- `HapticClips`: The controller supports haptic impulses defined by an audio clip.
- `TrackedHandPose`: The controller supports finger tracking, through capacitive sensors or similar. For example the Valve Index have this capability.

{{% callout info %}}
Haptic impulses in VR controllers refer to tactile feedback generated by embedded motors to simulate touch or force sensations for enhanced immersion.
{{% /callout %}}

## Controller Handedness

Handedness refers to the distinction between left-handed and right-handed controllers. In `Dual` controller setups each controller is grabbed using a different hand. In `Single` controller setups, handedness might be supported or not.
In devices with a single controller, such as the old Oculus Go, for example, the controller could be configured for the left hand or the right hand. In a gamepad, however, handedness does not apply.

Whether handedness is supported or not is indicated by the `IsHandednessSupported` property.

When handedness is supported, the following properties dictate the behavior:
- `Handedness`: Specifies the primary controller side In `Single` setups, it indicates which hand wields the controller. For `Dual` setups, it designates the hand wielding the primary controller. Input can be queried for left and right sides, as well as for primary and secondary.
- `Primary`/`Secondary`: Will translate to left or right depending on the `Handedness` assigned.

{{% callout tip %}}
Changing the Handedness property allows logic to be implemented that supports both left-handed and right-handed users.
{{% /callout %}}

When handedness is not supported, all calls will target the single controller.

## Ignoring Input

Occasionally, it can be useful to deactivate input from a controller.

`UxrControllerInput` provides two static methods for ignoring **any** input coming from a specific side.

```c#
static bool GetIgnoreControllerInput(UxrHandSide handSide)
static void SetIgnoreControllerInput(UxrHandSide handSide, bool ignore)
```

`GetIgnoreControllerInput()` checks whether ignoring is currently enabled on the specified side.
`SetIgnoreControllerInput()` enables or disables ignoring input coming from the specified side.

It is still possible, however, to get input from a controller that is being ignored. By default, all methods that query for user input will not return any data. These methods have an optional `getIgnoredInput` parameter that can be set to `true` to get input even if the controller is set to be ignored.

This functionality can be used to, for example, ignore input while a virtual controller is being manipulated to avoid teleporting:

{{< video src="/media/docs/programming-guide/input/getting-user-input/ControllerMapping.mp4" >}}

## Controller Elements

Despite variations among controllers, they share common elements. These include:
- **Buttons**, managed using `UxrInputButtons` flags.
- **Single-axis analog input**, such as trigger input, identified by the `UxrInput1D` type.
- **Two-axis analog input**, like an analog joystick, identified by the `UxrInput2D` type.

Buttons have discrete states, pressed or depressed, while analog inputs provide continuous input ranging from 0.0 to 1.0. `UxrInput1D` elements provide a single, analog input. `UxrAxis2D` provides an analog input with 2 components, such as the xy values of a joystick.

To identify controller elements, regardless of type, UltimateXR uses the `UxrControllerElements` enum supporting:
- `Joystick`: Primary joystick.
- `Joystick2`: Secondary joystick. Some controllers have 2 joysticks, such as the Windows Mixed Reality or the Valve Index.
- `DPad`: Directional pad. The D-pad typically consists of a cross-shaped arrangement of four directional buttons (up, down, left, and right). If not available, the primary joystick is usually mapped to the dpad.
- `Trigger`: Input button typically controlled with the index finger. The trigger is normally pressure-sensitive, allowing for varying degrees of input based on how firmly the user presses it.
- `Trigger2`: Secondary trigger. A gamepad, for instance, has 2 triggers.
- `Grip`: Input button typically controlled with the middle finger. Like the trigger, the grip is normally pressure-sensitive.
- `ThumbCapSense`: Capacitive sensor for the thumb.
- `IndexCapSense`: Capacitive sensor for the index finger.
- `MiddleCapSense`: Capacitive sensor for the middle finger.
- `RingCapSense`: Capacitive sensor for the ring finger.
- `LittleCapSense`: Capacitive sensor for the little finger.
- `Button1`: The button 1.
- `Button2`: The button 2.
- `Button3`: The button 3.
- `Button4`: The button 4.
- `Bumper`: The primary bumper, also called shoulder, button.
- `Bumper2`: The secondary bumper, also called shoulder, button. A gamepad, for instance, has 2 bumpers.
- `Back`: The back button.
- `Menu`: The menu button.

{{% callout info %}}
The `HasControllerElements()` method can be used to retrieve the elements that are present on the active controllers;
{{% /callout %}}

## Buttons

Buttons provide discrete input, either pressed or depressed.

UltimateXR supports the following buttons through the `UxrInputButtons` flags:

- `UxrInputButtons.Joystick`
- `UxrInputButtons.JoystickLeft`
- `UxrInputButtons.JoystickRight`
- `UxrInputButtons.JoystickUp`
- `UxrInputButtons.JoystickDown`
- `UxrInputButtons.Joystick2`
- `UxrInputButtons.Joystick2Left`
- `UxrInputButtons.Joystick2Right`
- `UxrInputButtons.Joystick2Up`
- `UxrInputButtons.Joystick2Down`
- `UxrInputButtons.DPadLeft`
- `UxrInputButtons.DPadRight`
- `UxrInputButtons.DPadUp`
- `UxrInputButtons.DPadDown`
- `UxrInputButtons.Trigger`
- `UxrInputButtons.Trigger2`
- `UxrInputButtons.Grip`
- `UxrInputButtons.ThumbCapSense`
- `UxrInputButtons.IndexCapSense`
- `UxrInputButtons.MiddleCapSense`
- `UxrInputButtons.RingCapSense`
- `UxrInputButtons.LittleCapSense`
- `UxrInputButtons.Button1`
- `UxrInputButtons.Button2`
- `UxrInputButtons.Button3`
- `UxrInputButtons.Button4`
- `UxrInputButtons.Bumper`
- `UxrInputButtons.Bumper2`
- `UxrInputButtons.Back`
- `UxrInputButtons.Menu`

{{% callout info %}}
The `ButtonToControllerElement()` method can be used together with `HasControllerElements()` to check whether a given button is present on the active controllers.
{{% /callout %}}

Input components will provide input for their available buttons. There are some special cases, where DPad, for example, will be assigned the joystick data as digital values if no DPad is available. This is to improve support when controllers lack certain elements.

Some buttons are analog in nature but will generate digital values when used with `UxrInputButtons`. For example `Trigger` or `Grip`.

### Button Input Methods

The following groups of methods can be used to check for button events. Each group offsers similar functionality but in different ways. One group may make querying easier than the others depending on the situation.

#### Press States

```c#
bool GetButtonsPress       (UxrHandSide handSide, UxrInputButtons buttons, bool getIgnoredInput)
bool GetButtonsPressAny    (UxrHandSide handSide, UxrInputButtons buttons, bool getIgnoredInput)
bool GetButtonsPressDown   (UxrHandSide handSide, UxrInputButtons buttons, bool getIgnoredInput)
bool GetButtonsPressDownAny(UxrHandSide handSide, UxrInputButtons buttons, bool getIgnoredInput)
bool GetButtonsPressUp     (UxrHandSide handSide, UxrInputButtons buttons, bool getIgnoredInput)
bool GetButtonsPressUpAny  (UxrHandSide handSide, UxrInputButtons buttons, bool getIgnoredInput)
```

In the methods above, `handSide` specifies the hand to check, while `buttons` denotes the specific button or buttons, indicated by combining flags. The optional parameter `getIgnoredInput` controls whether to retrieve input events for [ignored controllers](#ignoring-input). By default, it's set to `false`; using `true` should be limited to cases where it's truly necessary.

{{% callout tip %}}
Passing the `Handedness` property as `handSide` will query the primary hand. By maintaining a handedness setting, we can implement logic to support both left-handed and right-handed users.
{{% /callout %}}

These methods determine whether a button or group of buttons is currently pressed (`Press`), pressed during the current frame (`PressDown`), or released during the current frame (`PressUp`).
Since `buttons` are represented by flags, it's possible to combine multiple buttons and check for them simultaneously.
When combining multiple buttons with flags, these methods will return `true` only if **all** buttons are in the requested state. Conversely, the `Any` variations will return `true` as long as at least one button is in the requested state.

**Example1:** This line will check whether the right hand trigger was released. Here the trigger will work as a digital button, either pressed or depressed:

```c#
bool isTriggerReleased = UxrAvatar.LocalAvatarInput.GetButtonPressUp(UxrHandSide.Right, UxrInputButtons.Trigger);
```

**Example2:** This line will check whether the Button1 and Button2 from the left side are being pressed at the same time:

```c#
bool areButtonsPressed = UxrAvatar.LocalAvatarInput.GetButtonPress(UxrHandSide.Left, UxrInputButtons.Button1 | UxrInputButtons.Button2);
```

**Example3:** This line will check if either Button1 or Button2 from the left side is being pressed:

```c#
bool isAnyPressed = UxrAvatar.LocalAvatarInput.GetButtonPressAny(UxrHandSide.Left, UxrInputButtons.Button1 | UxrInputButtons.Button2);
```

#### Touch States

```c#
bool GetButtonsTouch       (UxrHandSide handSide, UxrInputButtons buttons, bool getIgnoredInput)
bool GetButtonsTouchAny    (UxrHandSide handSide, UxrInputButtons buttons, bool getIgnoredInput)
bool GetButtonsTouchDown   (UxrHandSide handSide, UxrInputButtons buttons, bool getIgnoredInput)
bool GetButtonsTouchDownAny(UxrHandSide handSide, UxrInputButtons buttons, bool getIgnoredInput)
bool GetButtonsTouchUp     (UxrHandSide handSide, UxrInputButtons buttons, bool getIgnoredInput)
bool GetButtonsTouchUpAny  (UxrHandSide handSide, UxrInputButtons buttons, bool getIgnoredInput)
```

These methods function similarly to their `Press` counterparts but are for Touch events instead of Press events. A Touch event registers with a light press of the button, while Press events require a full button press. Not all controllers and buttons support Touch events, as they require a capacitive sensor.

#### State flags

```c#
uint GetButtonPressFlags         (UxrHandSide handSide, bool getIgnoredInput)
uint GetButtonPressFlagsLastFrame(UxrHandSide handSide, bool getIgnoredInput)

uint GetButtonTouchFlags         (UxrHandSide handSide, bool getIgnoredInput)
uint GetButtonTouchFlagsLastFrame(UxrHandSide handSide, bool getIgnoredInput)
```

These methods return the state flags for button presses and touches. These flags will tell which buttons are currently being pressed or touched and which buttons were being pressed or touched the last frame.
Working with flags requires using bitwise logical operators.

`handSide` specifies the hand to check and the parameter `getIgnoredInput` controls whether to retrieve input events for ignored controllers. By default, it's set to `false`; using `true` should be limited to cases where it's truly necessary. Ignoring controller input is discussed [above](#ignoring-input).

Let's see some examples:

**Example1:** This line will check whether the left `Button1` is being pressed:

```c#
bool isButton1Pressed = (UxrAvatar.LocalAvatarInput.GetButtonPressFlags(UxrHandSide.Left) & UxrInputButtons.Button1) != 0;
```

**Example2:** This line will check whether the right `Button2` was pressed the last frame but not the current frame. This means that it was just released.

```c#
bool isButton2Released = (UxrAvatar.LocalAvatarInput.GetButtonPressFlags         (UxrHandSide.Right) & UxrInputButtons.Button2) == 0 &&
                         (UxrAvatar.LocalAvatarInput.GetButtonPressFlagsLastFrame(UxrHandSide.Right) & UxrInputButtons.Button2) != 0;
```

**Example3:** This line will check if any button from the left controller is being pressed:

```c#
bool isAnyLeftPressed = UxrAvatar.LocalAvatarInput.GetButtonPressFlags(UxrHandSide.Left) != 0;
```

**Example4:** This line will check if `Button1` and `Button2` are currently being pressed at the same time:

```c#
bool areBothPressed = (UxrAvatar.LocalAvatarInput.GetButtonPressFlags(UxrHandSide.Left) & (UxrInputButtons.Button1 | UxrInputButtons.Button2)) != 0;
```

{{% callout caution %}}
When using input functionality that relies on values from the current or previous frames, it's crucial to make sure that the queries are performed [after the input was updated](/docs/programming-guide/architecture/uxrmanager#stage-update-events). 
{{% /callout %}}

#### Event Querying

Event querying provides another way to check for controller input.

```c#
bool GetButtonsEvent   (UxrHandSide handSide, UxrInputButtons buttons, UxrButtonEventType buttonEventType, bool getIgnoredInput)
bool GetButtonsEventAny(UxrHandSide handSide, UxrInputButtons buttons, UxrButtonEventType buttonEventType, bool getIgnoredInput)
```

`handSide` specifies the hand to check, `buttons` specifies one or more button flags and the parameter `getIgnoredInput` controls whether to retrieve input events for ignored controllers. By default, it's set to `false`; using `true` should be limited to cases where it's truly necessary. Ignoring controller input is discussed [above](#ignoring-input).
Using the `buttonEventType` parameter, it is possible to check for different input events:
- `Touching`: whether the button is being touched.
- `TouchDown`: whether a touch started the present frame.
- `TouchUp`: whether the touch was released.
- `Pressing`: whether the button is being pressed.
- `PressDown`: whether a press started the present frame.
- `PressUp`: whether the press was released.

When combining multiple buttons with flags, `GetButtonsEvent()` will return `true` only if **all** buttons meet the event conditions. Conversely, `GetButtonsEventAny()` will return `true` as long as at least one button meets the criteria.

**Example1:** This line will check whether the right `Button1` is being pressed:

```c#
bool isButton1Pressed = UxrAvatar.LocalAvatarInput.GetButtonsEvent(UxrHandSide.Right, UxrInputButtons.Button1, UxrButtonEventType.Pressing);
```

**Example2:** This line will check whether the Button1 and Button2 from the left side are being pressed at the same time:

```c#
bool areButtonsPressed = UxrAvatar.LocalAvatarInput.GetButtonsEvent(UxrHandSide.Left, UxrInputButtons.Button1 | UxrInputButtons.Button2, UxrButtonEventType.Pressing);
```

**Example3:** This line will check if either Button1 or Button2 from the left side was released:

```c#
bool isAnyReleased = UxrAvatar.LocalAvatarInput.GetButtonsEventAny(UxrHandSide.Left, UxrInputButtons.Button1 | UxrInputButtons.Button2, UxrButtonEventType.PressUp);
```

### Button Events

Button input can also be retrieved using event subscription.

`GlobalButtonStateChanged` is a static event in `UxrControllerInput` raised on every button action.
The `sender` is the `UxrControllerInput` component that raised the event while the `UxrInputButtonEventArgs` will contain the following information:
- `HandSide`: Which hand performed the input.
- `Button`: The button that generated the event.
- `ButtonEventType`: The type of action performed on the button.

**Example:** This component will use events to check for user input

```c#
public class MyComponent : MonoBehaviour
{
	private void OnEnable()
	{
		UxrControllerInput.GlobalButtonStateChanged += UxrControllerInput_GlobalButtonStateChanged;
	}
	
	private void OnDisable()
	{
		UxrControllerInput.GlobalButtonStateChanged -= UxrControllerInput_GlobalButtonStateChanged;
	}
	
	private void UxrControllerInput_GlobalButtonStateChanged(object sender, UxrInputButtonEventArgs args)
	{
		Debug.Log($"Side {args.HandSide}, button {args.Button}, event {args.ButtonEventType}");
	}	
}
```

## `UxrInput1D`

`UxrInput1D` elements in a controller are those that provide a single, continuous input range between 0.0 and 1.0.
UltimateXR supports `Grip`, `Trigger` and `Trigger2`. While `Grip` and `Trigger` are present in most controllers, a `Trigger2` can be found in gamepads mostly.

{{% callout info %}}
The `Input1DToControllerElement()` method can be used together with `HasControllerElements()` to check whether a given element is present on the active controllers.
{{% /callout %}}

![](/media/docs/programming-guide/input/getting-user-input/GripAndTrigger.png)
**Image**: Examples of 1. Trigger, 2. Grip

### `UxrInput1D` Input Methods

`UxrInput1D` has a single method to retrieve the current value of a 1D control:

```c#
float GetInput1D(UxrHandSide handSide, UxrInput1D input1D, bool getIgnoredInput = false)
```

`handSide` specifies the hand to check and `input1D` which 1D control. The optional parameter `getIgnoredInput` controls whether to retrieve input events for [ignored controllers](#ignoring-input). By default, it's set to `false`; using `true` should be limited to cases where it's truly necessary.

**Example:** This line will get the trigger value for the right hand:

```c#
float rightTrigger = UxrAvatar.LocalAvatarInput.GetInput1D(UxrHandSide.Right, UxrInput1D.Trigger);
```

### `UxrInput1D` Events

Like buttons, `UxrInput1D` changes can also be retrieved using event subscription.

`GlobalInput1DChanged` is a static event in `UxrControllerInput` raised on every `UxrInput1D` change.
The `sender` is the `UxrControllerInput` component that raised the event while the `UxrInput1DEventArgs` will contain the following information:
- `HandSide`: Which hand performed the input.
- `Target`: The element that generated the event.
- `Value`: The new value, a float between [0.0f, 1.0f].

**Example:** This component will use events to check for user input

```c#
public class MyComponent : MonoBehaviour
{
	private void OnEnable()
	{
		UxrControllerInput.GlobalInput1DChanged += UxrControllerInput_GlobalInput1DChanged;
	}
	
	private void OnDisable()
	{
		UxrControllerInput.GlobalInput1DChanged -= UxrControllerInput_GlobalInput1DChanged;
	}
	
	private void UxrControllerInput_GlobalInput1DChanged(object sender, UxrInput1DEventArgs args)
	{
		Debug.Log($"Side {args.HandSide}, element {args.Target}, new value {args.Value}");
	}	
}
```

## `UxrInput2D`

`UxrInput2D` elements in a controller are those that provide two continuous values represented by a Vector2, such as joysticks or touchpads/trackpads. The two components have values in a range between 0.0 and 1.0, representing the horizontal axis and vertical axis, respectively.
UltimateXR supports `Joystick` and `Joystick2`. Most controllers come with a `Joystick`, while only a few add a secondary `Joystick2`.

{{% callout info %}}
The `Input2DToControllerElement()` method can be used together with `HasControllerElements()` to check whether a given element is present on the active controllers.
{{% /callout %}}

![](/media/docs/programming-guide/input/getting-user-input/WMR_Index.png)
**Image**: Examples of controllers with 2 joysticks. The windows Mixed Reality controllers (Left) have a joystick and a circular touchpad. Valve Index controllers (right) also have a joystick and touchpad. Even though the Valve Index touchpad has a more vertical shape, the input it provides is 2D.

It is possible to retrieve whether a controller has a joystick or touchpad as primary `Joystick` element using the `MainJoystickIsTouchpad` property.

### `UxrInput2D` Input Methods

`UxrInput2D` has a single method to retrieve the current value of a 2D control:

```c#
float GetInput2D(UxrHandSide handSide, UxrInput2D input2D, bool getIgnoredInput = false)
```

`handSide` specifies the hand to check and `input2D` which 2D control. The optional parameter `getIgnoredInput` controls whether to retrieve input events for [ignored controllers](#ignoring-input). By default, it's set to `false`; using `true` should be limited to cases where it's truly necessary.

**Example:** This line will get the joystick direction for the right hand:

```c#
Vector2 rightJoystick = UxrAvatar.LocalAvatarInput.GetInput2D(UxrHandSide.Right, UxrInput2D.Joystick);
```

### `UxrInput2D` Events

Like buttons, `UxrInput2D` changes can also be retrieved using event subscription.

`GlobalInput2DChanged` is a static event in `UxrControllerInput` raised on every `UxrInput2D` change.
The `sender` is the `UxrControllerInput` component that raised the event while the `UxrInput2DEventArgs` will contain the following information:
- `HandSide`: Which hand performed the input.
- `Target`: The element that generated the event.
- `Value`: The new value, a Vector2 with each component between [0.0f, 1.0f].

**Example:** This component will use events to check for user input

```c#
public class MyComponent : MonoBehaviour
{
	private void OnEnable()
	{
		UxrControllerInput.GlobalInput2DChanged += UxrControllerInput_GlobalInput2DChanged;
	}
	
	private void OnDisable()
	{
		UxrControllerInput.GlobalInput2DChanged -= UxrControllerInput_GlobalInput2DChanged;
	}
	
	private void UxrControllerInput_GlobalInput2DChanged(object sender, UxrInput2DEventArgs args)
	{
		Debug.Log($"Side {args.HandSide}, element {args.Target}, new value {args.Value}");
	}	
}
```

## More `UxrControllerInput` Properties

- `LeftControllerName`: Gets the left controller name.
- `RightControllerName`: Gets the right controller name. 
- `MainJoystickIsTouchpad`: Gets whether the main joystick is a touchpad.
- `JoystickDeadZone`: Controls the joystick deadzone, which is the center area where the joystick will report a (0, 0) value. it is measured as a radius in a range between 0.0 and 1.0.

## More `UxrControllerInput` Events

- `GlobalControllerConnected`: Event raised whenever a controller was connected or disconnected.
- `GlobalHapticRequesting`:  Event raised whenever haptic feedback is requested.
- `Updating`: Event raised before the input is about to be updated in a frame.
- `Updated`: Event raised right after the finished updating in a frame.

## DebugInputPanel

The DebugInputPanel is a prefab located at /Prefabs/UI/DebugInput/DebugInputPanel that can be used to debug controller input. It can be dropped in any scene and will show the input state of the connected controllers at runtime.
It can also be found in the [example scene](/docs/getting-started/example-scene).

It will show all 3 input element types. From top to bottom:
- `UxrInput1D` elements, as a white dot inside a vertical bar.
- `UxrInput2D` elements, as a white dot inside a box.
- `UxrButtons` elements, as 6 LEDs that will light up with these events, in order from top to bottom:
  - `Touching`: whether the button is being touched.
  - `TouchDown`: whether the button started being touched the present frame.
  - `TouchUp`: whether the touch was released.
  - `Pressing`: whether the button is being pressed.
  - `PressDown`: whether the button started being pressed the present frame.
  - `PressUp`: whether the press was released.

{{< video src="/media/docs/programming-guide/input/getting-user-input/DebugInputPanel.mp4" >}}
